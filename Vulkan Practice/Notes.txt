If any kind of fatal error occurs during execution then we'll throw a std::runtime_error exception with a descriptive message,
which will propagate back to the main function and be printed to the command prompt. To handle a variety of standard exception
types as well, we catch the more general std::exception.

Just like each chunk of memory allocated with malloc requires a call to free, every Vulkan object that we create needs to be
explicitly destroyed when we no longer need it. In C++ it is possible to perform automatic resource management using RAII or
smart pointers provided in the <memory> header.

Vulkan objects are either created directly with functions like vkCreateXXX, or allocated through another object with functions
like vkAllocateXXX. After making sure that an object is no longer used anywhere, you need to destroy it with the counterparts
vkDestroyXXX and vkFreeXXX.

The very first thing you need to do is initialize the Vulkan library by creating an instance. The instance is the connection
between your application and the Vulkan library and creating it involves specifying some details about your application to
the driver.

If you look at the vkCreateInstance documentation then you'll see that one of the possible error codes is 
VK_ERROR_EXTENSION_NOT_PRESENT.

To retrieve a list of supported extensions before creating an instance, there's the vkEnumerateInstanceExtensionProperties
function. It takes a pointer to a variable that stores the number of extensions and an array of VkExtensionProperties to
store details of the extensions. It also takes an optional first parameter that allows us to filter extensions by a specific
validation layer.

Validation layers are optional components that hook into Vulkan function calls to apply additional operations.

You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the
best of both worlds.

To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with
a callback using the VK_EXT_debug_utils extension.

debugCallback function's first parameter specifies the severity of the message:

- VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: Diagnostic message

- VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: Informational message like the creation of a resource

- VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: Message about behavior that is not necessarily an error, but very likely a
bug in your application

- VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: Message about behavior that is invalid and may cause crashes

The messageType parameter of debugCallback function can have the following values:

- VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: Some event has happened that is unrelated to the specification or performance

- VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: Something has happened that violates the specification or indicates a
possible mistake

- VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: Potential non-optimal use of Vulkan

The pCallbackData parameter refers to a VkDebugUtilsMessengerCallbackDataEXT struct containing the details of the message
itself, with the most important members being:

pMessage: The debug message as a null-terminated string
pObjects: Array of Vulkan object handles related to the message
objectCount: Number of objects in array

The pUserData parameter contains a pointer that was specified during the setup of the callback and allows you to pass your
own data to it.

Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers
we will render to before we visualize them on the screen. This infrastructure is known as the swap chain and must be created
explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our
application will acquire such an image to draw to it, and then return it to the queue.

Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example because they
are designed for servers and don't have any display outputs. Secondly, since image presentation is heavily tied into the
window system and the surfaces associated with windows, it is not actually part of the Vulkan core. You have to enable the
VK_KHR_swapchain device extension after querying for its support.

Note that the Vulkan header file provides a nice macro VK_KHR_SWAPCHAIN_EXTENSION_NAME that is defined as VK_KHR_swapchain.
The advantage of using this macro is that the compiler will catch misspellings.

Just checking if a swap chain is available is not sufficient, because it may not actually be compatible with our window
surface. Creating a swap chain also involves a lot more settings than instance and device creation, so we need to query for some more details before we're able to proceed.

There are basically three kinds of properties we need to check:

1. Basic surface capabilities (min/max number of images in swap chain, min/max width and height of images)
2. Surface formats (pixel format, color space)
3. Available presentation modes

Each VkSurfaceFormatKHR entry contains a format and a colorSpace member. The format member specifies the color channels and
types. For example, VK_FORMAT_B8G8R8A8_SRGB means that we store the B, G, R and alpha channels in that order with an 8 bit
unsigned integer for a total of 32 bits per pixel. The colorSpace member indicates if the SRGB color space is supported or
not using the VK_COLOR_SPACE_SRGB_NONLINEAR_KHR flag. Note that this flag used to be called VK_COLORSPACE_SRGB_NONLINEAR_KHR
in old versions of the specification.

GLFW uses two units when measuring sizes: pixels and screen coordinates. For example, the resolution WIDTH, HEIGHT that we
specified earlier when creating the window is measured in screen coordinates. But Vulkan works with pixels, so the swap chain
extent must be specified in pixels as well. Unfortunately, if you are using a high DPI display (like Apple's Retina display),
screen coordinates don't correspond to pixels. Instead, due to the higher pixel density, the resolution of the window in pixel
will be larger than the resolution in screen coordinates. So if Vulkan doesn't fix the swap extent for us, we can't just use
the original WIDTH, HEIGHT. Instead, we must use glfwGetFramebufferSize to query the resolution of the window in pixel
before matching it against the minimum and maximum image extent.

To use any VkImage, including those in the swap chain, in the render pipeline we have to create a VkImageView object. An
image view is quite literally a view into an image. It describes how to access the image and which part of the image to
access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels.